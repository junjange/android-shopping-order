# android-shopping-order

### 기능 요구 사항

- [x] 데이터가 로딩되기 전 상태에서는 스켈레톤 UI를 노출한다.
- [x] 서버를 연동한다.
- [x] 사용자 인증 정보를 저장한다. (적절한 저장 방법을 선택한다)
- [x] 장바구니 화면에서 특정 상품만 골라 주문하기 버튼을 누를 수 있다. 
- [x] 별도의 화면에서 상품 추천 알고리즘으로 사용자에게 적절한 상품을 추천해준다.
- [x] 상품 추천 알고리즘은 최근 본 상품 카테고리를 기반으로 최대 10개 노출한다. 
  - [x] 예를 들어 가장 최근에 본 상품이 fashion 카테고리라면, fashion 상품 10개 노출 
  - [x] 해당 카테고리 상품이 10개 미만이라면 해당하는 개수만큼만 노출 
  - [x] 장바구니에 이미 추가된 상품이라면 미노출 
- [x] 추천된 상품을 해당 화면에서 바로 추가하여 같이 주문할 수 있다.

# 낙서장

## DataSource 와 Repository
DataSource와 Repository는 데이터 관리 계층에서 중요한 역할을 하는 두 가지 개념이다.

### DataSource
DataSource는 데이터 소스와의 직접적인 상호작용을 담당한다. 이는 데이터의 출처에 따라 분류될 수 있다. 
이번 미션에서느 Local과 Remote로 나누어 안드로이드 내부/외부에 대한 데이터 CRUD하도록 했다.

### Repository
Repository는 여러 DataSource를 결합하고, 비즈니스 로직을 처리하며, ViewModel이나 UseCase와 같은 상위 계층에 일관된 데이터 접근 방법을 제공한다. 
Repository에서는 로컬 및 원격 데이터 소스에서 데이터를 가져와 통합하거나 필요한 비즈니스 로직을 수행한다.

### DataSource 와 Repository를 왜 나누어야 할까?
DataSource와 Repository를 나누는 이유는 코드의 구조화와 유지보수성을 높이기 위해서이다. 
이를 통해 관심사를 분리하고, 코드 재사용성과 테스트 용이성을 향상시킨다. 
또한, 변경 사항이 특정 클래스에 국한되므로 유지보수가 쉽고, 유연성과 확장성을 제공한다. 
이로써 각 컴포넌트는 독립적으로 관리되고, 데이터 소스의 변경이 다른 부분에 영향을 미치지 않는다.

이번 미션에서 위에서 언급한 이점을 경험했다.
쇼핑 장바구니에서 쇼핑 주문으로 코드를 마이그레이션할 때, 장바구니 데이터를 로컬 DB에서 서버 API 호출로 전환해야 했다. 
이 과정에서 DataSource와 Repository를 잘 분리해 둔 덕분에, DataSource의 형태를 DB에서 API 호출로 데이터를 가져오는 것으로 수정하는 것만으로 이전과 동일한 기능을 유지할 수 있었다. 
이 경험은 코드의 유연성과 확장성, 유지보수성을 크게 향상시켰음을 실감한 순간이었다.


## 설계의 중요성
이번 미션을 하면서 설계가 매우 매우 중요하다는 것을 깨달았다.
깨닫게 한 사건은 다음과 같다.
```
- 장바구니에 상품을 담기 위해서는 `product id`를 `request`로 넘겨야 한다.
- 장바구니에 담긴 상품의 수량을 변경하기 위해서는 `cart id`를 `request`로 넘겨야 한다.
```

위와 같이 API 스펙이 주어졌을 때, 상품 목록에 대한 데이터를 `cartId`, `product`, `quanutity` 를 포함하고 있는 `Cart`로 지정했다.
결국, 장바구니에 없는 상품은 `cartId`, `quantity`를 디폴트 파라미터로 초기화했고, 장바구니에 있는 상품은 해당 상품의 `cartId`와 `quantity`로 초기화 했다.
나는 단순히 간단하게 구현하기 위해 위처럼 도메인을 설계했고, 덕분에 쉽게 로직을 구현할 수 있었다.

그러나 위처럼 개발을 쉽게 하기 위해 도메인을 설계하고, 설계에 대한 설명도 없다면(사실 셜명이 있어도 이해하지 못할 수 있다), 다른 개발자가 봤을 때 납득하지 못하는 부분이 생길 수 있다.
- 상품 목록이기 때문에 당연히 상품 목록에 대한 아이템이 `Product`라고 예상하겠지만, 그것이 아닌 `Cart`라는 것에서 의문이 들 수 있다.
- 상품을 장바구니에 추가했을 때 장바구니에 상품을 담는다는 로직으로 예상하겠지만, 이미 있는 아이템에 `cartId`를 셋업해주는 게 어색하다고 생각할 수 있다.

위 같이 다른 개발자가 처음 봤을 때 이상하다고 느낄 수 있는 부분이 있으며 언급한 것보다 더 많을 수 있다.
그 외에도 내가 봤을 때 이해할 수 있으니 다른 사람이 봐도 이해할 수 있겠지?라고 생각하며 구현한 로직들이 상당수 있었다.

예전에 프로젝트를 설명할 때나 자소서에 나의 경험을 쓸 때도 비슷한 코멘트를 받은 적이 있었다.
프로젝트나 경험은 내가 직접 했기에 내가 말하면서도 쉽게 이해할 수 있지만, 다른 사람이 그것을 보고 들었을 때는 무슨 이야기인지 이해하지 못할 수 있다.

누군가가 듣고 보았을 때도 이해할 수 있는 언어로 말하고 코드를 작성해야할 것 같다.
다시 한번 설계의 중요성을 알게 되었다.


## 로딩 상태를 Base에서 관리하는 것은, 편리할 수 있지만 매우 위험한 문제를 가지고 있다. 그럼 우리는 이 문제를 어떻게 해결해 수 있을까?
문제는 다음과 같다.
```
가령, 로딩이 필요한 비즈니스 로직이 한번에 5개의 요청이 들어왔다고 가정 해봅시다.
그렇다면 각각 함수에서는 showLoading()을 5번까지 요청을 합니다.
이어서 하나의 함수라도 요청이 끝난다면 hideLoading()을 부르게 됩니다.

그러면 아직 4개의 함수가 끝나지 않았는데 UI가 보이는 문제로 이어집니다.
여러가지 솔루션이 있지만, 지금 생각하기에는 난이도가 다소 높을 지 모릅니다.
```

지금 당장 생각나는 솔루션은 로딩 상태를 Base에서 관리하는 것이 아니라 각 페이지별로 각 컴포넌트의 로딩을 관리하는 것이다.
즉, 페이지에서 로딩이 필요한 컴포넌트마다 개별적으로 로딩 상태를 관리하는 것이다. 
모바일 특성상 로딩이 필요한 컴포넌트가 많지 않을 것으로 예상되므로, 이러한 방식이 문제를 해결할 수 있는 방법이 될 것 같다.
