# android-shopping-order

### 기능 요구 사항

- [x] 데이터가 로딩되기 전 상태에서는 스켈레톤 UI를 노출한다.
- [x] 서버를 연동한다.
- [x] 사용자 인증 정보를 저장한다. (적절한 저장 방법을 선택한다)
- [x] 장바구니 화면에서 특정 상품만 골라 주문하기 버튼을 누를 수 있다. 
- [x] 별도의 화면에서 상품 추천 알고리즘으로 사용자에게 적절한 상품을 추천해준다.
- [x] 상품 추천 알고리즘은 최근 본 상품 카테고리를 기반으로 최대 10개 노출한다. 
  - [x] 예를 들어 가장 최근에 본 상품이 fashion 카테고리라면, fashion 상품 10개 노출 
  - [x] 해당 카테고리 상품이 10개 미만이라면 해당하는 개수만큼만 노출 
  - [x] 장바구니에 이미 추가된 상품이라면 미노출 
- [x] 추천된 상품을 해당 화면에서 바로 추가하여 같이 주문할 수 있다.

# 낙서장

## DataSource 와 Repository
DataSource와 Repository는 데이터 관리 계층에서 중요한 역할을 하는 두 가지 개념이다.

### DataSource
DataSource는 데이터 소스와의 직접적인 상호작용을 담당한다. 이는 데이터의 출처에 따라 분류될 수 있다. 
이번 미션에서느 Local과 Remote로 나누어 안드로이드 내부/외부에 대한 데이터 CRUD하도록 했다.

### Repository
Repository는 여러 DataSource를 결합하고, 비즈니스 로직을 처리하며, ViewModel이나 UseCase와 같은 상위 계층에 일관된 데이터 접근 방법을 제공한다. 
Repository에서는 로컬 및 원격 데이터 소스에서 데이터를 가져와 통합하거나 필요한 비즈니스 로직을 수행한다.

### DataSource 와 Repository를 왜 나누어야 할까?
DataSource와 Repository를 나누는 이유는 코드의 구조화와 유지보수성을 높이기 위해서이다. 
이를 통해 관심사를 분리하고, 코드 재사용성과 테스트 용이성을 향상시킨다. 
또한, 변경 사항이 특정 클래스에 국한되므로 유지보수가 쉽고, 유연성과 확장성을 제공한다. 
이로써 각 컴포넌트는 독립적으로 관리되고, 데이터 소스의 변경이 다른 부분에 영향을 미치지 않는다.

이번 미션에서 위에서 언급한 이점을 경험했다.
쇼핑 장바구니에서 쇼핑 주문으로 코드를 마이그레이션할 때, 장바구니 데이터를 로컬 DB에서 서버 API 호출로 전환해야 했다. 
이 과정에서 DataSource와 Repository를 잘 분리해 둔 덕분에, DataSource의 형태를 DB에서 API 호출로 데이터를 가져오는 것으로 수정하는 것만으로 이전과 동일한 기능을 유지할 수 있었다. 
이 경험은 코드의 유연성과 확장성, 유지보수성을 크게 향상시켰음을 실감한 순간이었다.
